import csv
import numpy as np
import requests
import os

class CovidData(object):
    """Reads time series data on spread of COVID-19 as published by Johns Hopkins University here: https://github.com/CSSEGISandData/COVID-19
    To load the data run the loadData(path = '') method. If no path to folder with the JHU csv files is given it downloads 
    the latest csv files from github and saves them in the current working directory.
    To access the data for a given country run getData(coutry, province = '') method. If no province is given it returns total count for that country. 
    To see list of countries, run getCountries()
    To see list of provinces, run getProvinces(country)
    To get estimate of true cases from the number of deaths run estimateTrueCases(country, province = '')
    """
    def __init__(self):
        # list of tables - one per csv file
        self.tables = {}
        # list of dates at which the data were recorded
        self.dates = []
        self. urlPartial = 'https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/'
        self.filenames = {'confirmed' : 'time_series_covid19_confirmed_global.csv',
                          'dead' : 'time_series_covid19_deaths_global.csv',
                          'recovered' :'time_series_covid19_recovered_global.csv'}
        
    
    def loadData(self, path = ''):
        """Reads the data. If path is given it looks for the csv files there. If not it tries to read the data from the web.
        """
        if path:
            self.loadLocalData(path)
        else:
            self.loadRemoteData()
    
    def loadRemoteData(self):
        """Downloads the JHU csv file from the web and saves them in the working directory. Then it loads the csv files it just saved."""
        self.downloadData()
        cwd = os.getcwd()
        self.loadLocalData(cwd + '/')
    
    
    #this needs to download the right files
    def downloadData(self):
        """Downloads the JHU csv file from the web and saves them in the working directory."""
        for key in self.filenames:
            url = self.urlPartial + self.filenames[key]
            r = requests.get(url, allow_redirects=True)
            open(self.filenames[key], 'wb').write(r.content)
        
        
    
    #this needs to read the right files
    def loadLocalData(self, path):
        """Reads data in the three csv files provided by JHU. Needs path to the csv files."""
        # fill the list of dates at which the data were recorded
        
        # load the csv files and store them in tables dict
        for key in self.filenames:
            #print(file)
            filename = self.filenames[key]
            table = self.getTable(path+filename)
            self.tables[key] = table
            
        # make a list of dates
        key = list(self.tables.keys())[0]
        table = self.tables[key]
        row = table[0]
        self.dates = row[4:]
              
        
    def getTable(self, filename):
        """Returns a list of rows in given csv file. filename is a valid path to the csv file"""
        table = []
        with open(filename) as csvfile:
            creader = csv.reader(csvfile)
            for row in creader:
                table.append(row)
        return table
    
    
    def readRow(self, n, table):
        """Reads a given row from list of rows (generated by get_rows) and returns (country, province, data). Do not use on the first row. """
        row = table[n]
        #print(row)
        province = row[0]
        country = row[1]
        data = []
        for x in row[4:]:
            if x:
                data.append(float(x))
            else:
                data.append(float(0))
        #data = np.array([float(x) for x in row[4:]])
        return (province, country, data)
    
    
    def getCountries(self):
        """Returns a list of countries of which there are data."""
        countries = []
        for key in self.tables:
            table = self.tables[key]
            for i in range(1, len(table)):
                line = table[i]
                country = line[1]
                if not country in countries:
                    countries.append(country)
        return countries
        
    
    def getProvinces(self, country):
        """Returns a list of provinces for a given country."""
        provinces = []
        for key in self.tables:
            table = self.tables[key]
            for i in range(1, len(table)):
                line = table[i]
                c = line[1]
                if c == country:
                    province = line[0]
                    if not province in provinces:
                        provinces.append(province)
        return provinces
    
    def getData(self, country, province = ''):
        """Returns a dict with all relevant data for specified coutry and province. """
        
        out = {'country':country, 'province':province}
        
        for key in self.tables:
            table = self.tables[key]
            data = None
            for i in range(1,len(table)):
                row = self.readRow(i,table)
                if row[1] == country and row[0] == province:
                    data = row[2]
            out[key] = data
                    
        dates = self.dates
        days = range(len(dates))
        out['dates'] = dates
        out['days'] = days
        
        return out
    
    def estimateTrueCases(self, country, province = '', fatalityRate = 0.01, timeToDeath = 17.3):
        """Returns estimate number of infected people based on fatality count. 
        Uses estimates of fatality rate and of time it takes for average person to die after getting infected.
        """
        fr = fatalityRate
        t = int(timeToDeath)
        data = self.getData(country, province)
        deaths = data['dead']
        
        estimate =  np.zeros(len(deaths))
        for i in range(len(deaths)):
            if i + t + 1 < (len(deaths)):
                a = deaths[i + t]  
                b = deaths[i + t + 1]
                n = a*(timeToDeath - t) + b*(1 - timeToDeath + t)
                estimate[i] = n/fr
            else:
                estimate[i] = np.nan
        out = {'country' : country, 'province': province, 'fatalityRate' : fatalityRate, 'timeToDeath': timeToDeath, 'estimate' : estimate, 'days': data['days'], 'dates' : data['dates']}
        return out
    
    
    def estimateGrowthRate(self, country, province = '', minCases = 50, averagingInterval = 1):
        """Returns relative day-to-day change C_rel of number of cases in percent: 
        C_rel(day) = (cases(day)/cases(day-1) - 1)*100 
        Calculation is only done when cases > minCases. This helps 
        to avoid missbehaviour when there are too few cases (before
        the exponential growth of the epidemic kicked in). 
        Averaging interval needs to be integer. If averagingInterval is > 1 
        then the returned growth is average over past averagingInterval days.
        """
        data = self.getData(country, province)
        out = {'country': country, 'province': province, 'dates': data['dates'], 'days': data['days']}
        for key in self.filenames:
            cases = data[key]
            ris = [] # array of relative increases
            for i, n in enumerate(cases):
                if i  - averagingInterval < 0: # no relative cases on first few days
                    ri = np.nan 
                elif n < minCases or cases[i - averagingInterval] < minCases:
                    ri = np.nan # no relative increase when we do not have enough cases
                else:
                    # geometric average of ratios N(t)/N(t-1) during the averaging interval
                    ratio = n/cases[i-averagingInterval]
                    averageRatio = np.power(ratio, 1/averagingInterval)
                    # calculate average growth rate in percent
                    ri = (averageRatio - 1)*100
                ris.append(ri)
            ris = np.array(ris)
            out[key + 'RC'] = ris
        return out
            
                    
        
